@using DrugStockWeb.Models.Constancts
@model DrugStockWeb.ViewModels.Account.LoginViewModel

@{
    Layout = "~/Views/Shared/_LoginLayout.cshtml";
    ViewBag.Title = "فرم احراز هویت ";
}

<div class="limiter"  style="direction: rtl">
    <div class="container-login100" style="background-image: url('../../Content/Account/images/bg-02.jpg');">
        <div class="wrap-login100 p-l-110 p-r-110 p-t-62 p-b-33">
            @using (Html.BeginForm(
                        "Login",
                        "Account",
                        new { ReturnUrl = ViewBag.ReturnUrl },
                        FormMethod.Post,
                        new { 
                            @class = "form-horizontal", 
                            role = "form",
                            autocomplete = "off"
                        }))
            {
                if (ViewBag.CommonHashMsg != "" && ViewBag.CommonHashMsg != null)
                {
                    <div class="alert alert-danger  margin-bottom-0"
                         style="margin-bottom: 5px;">
                        @ViewBag.CommonHashMsg
                    </div>
                }
                @Html.AntiForgeryToken()
                <span class="login100-form-title p-b-53">
                    فرم احراز هویت
                </span>
                <input type="text" name="fakeuser" style="display:none" autocomplete="username" />
                <input type="password" name="fakepass" style="display:none" autocomplete="current-password" />
                @Html.ValidationSummary(true)
                <div class="p-t-31 p-b-9">
                    <span class="txt1">
                        نام کاربری
                    </span>
                </div>
                <div class="wrap-input100 validate-input" data-validate="Username is required">
                    @Html.TextBoxFor(m => m.UserName, new { 
                        @class = "form-control",
                        autocomplete = "username"
                    })                    @Html.ValidationMessageFor(m => m.UserName, "", new { @style = "color:red" })
                </div>

                <div class="p-t-13 p-b-9">
                    <span class="txt1">
                        رمز عبور
                    </span>
                </div>
                <div class="wrap-input100 validate-input" data-validate="Password is required">
                    @Html.PasswordFor(m => m.Password, new { 
                        @class = "form-control", 
                        autocomplete = "new-password"
                    })                    @Html.ValidationMessageFor(m => m.Password, "", new { @style = "color:red" })
                    <span class="focus-input100"></span>
                </div>
                <div class="p-t-13 p-b-9">
                    <span class="txt1">کد امنیتی</span>
                </div>
                <div class="wrap-input100 validate-input">
                    <img src="@Url.Action("CaptchaImage", "Account")" alt="Captcha" style="border:1px solid #ccc;" />
                    @Html.TextBox("CaptchaCode", null, new { @class = "form-control", placeholder = "کد بالا را وارد کنید" })
                    @Html.ValidationMessage("CaptchaCode", "", new { @style = "color:red" })
                </div>
                @* <a href="#" class="txt2 bo1 m-l-5"> *@
                @*     Forgot? *@
                @* </a> *@
                <div class="container-login100-form-btn m-t-17">
                    <button class="login100-form-btn">
                        ورود
                    </button>
                </div>


            }
        </div>
    </div>
</div>





@section Scripts {
    <script>


        const keyBase64 = '@ViewBag.AESKey';
        const ivBase64 = '@ViewBag.AESIV';
        // کلید و IV برای AES (در عمل بهتر است از سرور دریافت شود)
        const keyBytes = Uint8Array.from(atob(keyBase64), c => c.charCodeAt(0));
        const ivBytes = Uint8Array.from(atob(ivBase64), c => c.charCodeAt(0));

        async function importKey(keyData) {
            return await crypto.subtle.importKey(
                "raw",
                keyData,
                { name: "AES-CBC" },
                false,
                ["encrypt"]
            );
        }

        async function encryptAES(password) {
            const key = await importKey(keyBytes);
            const encoder = new TextEncoder();
            const data = encoder.encode(password);

            const encryptedBuffer = await crypto.subtle.encrypt(
                { name: "AES-CBC", iv: ivBytes },
                key,
                data
            );

            return btoa(String.fromCharCode(...new Uint8Array(encryptedBuffer)));
        }

        // override submit form
        $('form').on('submit', async function (e) {
            e.preventDefault(); // جلوگیری از submit معمولی

            // گرفتن مقدار رمز عبور
            const passwordInput = $('input[name="Password"]');
            const plainPassword = passwordInput.val();

            // رمزگذاری AES
            const encryptedPassword = await encryptAES(plainPassword);

            // جایگزین کردن مقدار رمز با نسخه رمز شده
            passwordInput.val(encryptedPassword);

            // submit فرم به صورت معمول
            this.submit();
            setTimeout(function () {
                $('input[type=password]').val('');
            }, 50);
        });

        // پاک کردن password بعد از submit

    </script>
    @Scripts.Render("~/bundles/jqueryval")
}